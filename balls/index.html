<!DOCTYPE html>
<html>
<head>
<title>2D Ball Simulation</title>
<style>
body { margin: 0; overflow: hidden; }
canvas { display: block; }
button { position: absolute; top: 10px; right: 10px; }
</style>
<script src="p2.min.js"></script>
</head>
<body>
<canvas id="canvas"></canvas>

<script>
window.addEventListener('load', function() {

    console.log('p2 version check:', p2); // Debug p2 availability

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    const radius = 180; // Increased radius
    console.log('Using circle radius:', radius);
    const ballRadius = 15; // Increased ball radius

    const world = new p2.World({ gravity: [0, -9.82] });

    const planeMaterial = new p2.Material();
    const ballMaterial = new p2.Material();

    // Add planes in a circle to confine the ball inside:
    const segments = 16; // Increase segments for smoother boundary
    const planes = [];
    for (let i = 0; i < segments; i++) {
        const angle = i * (2 * Math.PI / segments);
        const planeBody = new p2.Body({ position: [centerX, centerY], angle: angle, type: p2.Body.STATIC });
        const planeShape = new p2.Plane({});
        planeShape.material = planeMaterial; // Moved inside the loop
        planeBody.addShape(planeShape);
        world.addBody(planeBody);
        planes.push({ body: planeBody, angle: angle });
    }

    // Adjust restitution so the ball bounces off planes:
    world.addContactMaterial(new p2.ContactMaterial(planeMaterial, ballMaterial, { restitution: 0.9, friction: 0 }));

    // Assign the planeMaterial to each planeShape, and ballMaterial to the ball:
    const ballShape = new p2.Circle({ radius: ballRadius });
    ballShape.material = ballMaterial; // Assign material right after creation
    const ballBody = new p2.Body({
        mass: 1,
        position: [centerX, centerY + 50], // More offset
        velocity: [10, 0], // Increased initial velocity
        damping: 0, // No damping
        angularDamping: 0 // No angular damping
    });
    ballBody.addShape(ballShape);
    world.addBody(ballBody);

    console.log(`Initial Ball Position: (${ballBody.position[0]}, ${ballBody.position[1]})`);
    console.log(`Initial Ball Velocity: (${ballBody.velocity[0]}, ${ballBody.velocity[1]})`);

    function animate() {
        world.step(1 / 60);

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
        ctx.stroke();

        // Draw radial lines
        ctx.strokeStyle = 'black';
        planes.forEach(plane => {
            const x1 = centerX + Math.cos(plane.angle) * radius;
            const y1 = centerY + Math.sin(plane.angle) * radius;
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(x1, y1);
            ctx.stroke();
        });

        // Draw small solid black circle at the center
        ctx.fillStyle = 'black';
        ctx.beginPath();
        ctx.arc(centerX, centerY, 5, 0, 2 * Math.PI); // Small circle with radius 5
        ctx.fill();

        ctx.fillStyle = 'black';
        ctx.beginPath();
        ctx.arc(ballBody.position[0], ballBody.position[1], ballRadius, 0, 2 * Math.PI);
        ctx.fill();

        console.log(`Ball Position: (${ballBody.position[0]}, ${ballBody.position[1]})`);
        console.log(`Ball Velocity: (${ballBody.velocity[0]}, ${ballBody.velocity[1]})`);

        setTimeout(() => {
            requestAnimationFrame(animate);
        }, 500); // Delay next frame by 500ms
    }

    animate();

}); // End of window.addEventListener('load')
</script>

</body>
</html>