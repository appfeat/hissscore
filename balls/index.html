<!--
Summary:
- Uses Matter.js to simulate balls within a circular container bounded by walls.
- A hero ball (red) is initially created.
- On collision between a hero ball and a wall, a child ball is spawned:
    * Every 10th spawned ball is a hero (red) ball; others are yellow.
- Yellow balls have a 30% chance every 5 seconds to turn red.
- Red balls continuously toggle between red and blue every 5 seconds.
- When two blue balls collide, they both turn yellow and stop toggling.
- All balls maintain a constant speed throughout the simulation.
- A cleanup routine periodically removes balls that exceed speed limits or move out of bounds.
- Panels display ball count, simulation variables, results, and sound control.
-->
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport"
          content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Matter.js Circle Simulation</title>
    <script src="https://cdn.jsdelivr.net/npm/matter-js@0.20.0/build/matter.min.js"></script>
    <link href="https://fonts.googleapis.com/css?family=Roboto&display=swap" rel="stylesheet">
    <style>
      html, body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background-color: #121212;
        color: #ffffff;
        font-family: 'Roboto', sans-serif;  /* Changed font */
      }
      canvas {
        display: block;
        background-color: #1e1e1e; /* Night mode background color */
      }
      /* Center panels horizontally using left:50% + transform */
      #ball-counter, #results, #simulation-variables, #sound-control {
        position: fixed;
        background: rgba(0, 0, 0, 0.7);
        color: #ffffff;
        padding: 10px;
        font-family: 'Roboto', sans-serif;
        font-size: 14px;
        border-radius: 5px;
        left: 50%;               /* Center horizontally */
        transform: translateX(-50%);
      }
      /* Adjust vertical positions */
      #ball-counter {
        top: 10px;
      }
      #results {
        bottom: 10px;
      }
      #simulation-variables {
        top: 10px;
        display: none; /* Hide the variables panel */
      }
      #sound-control {
        bottom: 10px;
        left:80%;  /* Adjust horizontal position */
      }
    </style>
  </head>
  <body>
    <canvas id="world"></canvas>
    <!-- Ball counter element -->
    <div id="ball-counter">
      Balls: 0
    </div>
    <!-- Results area now includes a countdown display -->
    <div id="results">
      Results will appear here...
    </div>
    <!-- New area to display important simulation variables -->
    <div id="simulation-variables">
      Variables will appear here...
    </div>
    <!-- Sound control element -->
    <div id="sound-control">
      <button id="mute-toggle">Unmute</button>
    </div>
    <audio id="collision-sound" src="collision.mp3" preload="auto"></audio>
    <script>
      // Matter.js module aliases
      const { Engine, Render, Runner, World, Bodies, Body, Events } = Matter;

      // Constants
      // Use responsive canvas dimensions for mobile display
      const width = window.innerWidth;
      const height = window.innerHeight;
      const containerRadius = Math.min(width, height) * 0.4;
      const ballRadius = 8;
      const initialBallCount = 1;
      const MAX_BALLS = 500;
      const containerX = width / 2;
      const containerY = height / 2;
      // New speed and force constants
      const INITIAL_SPEED = 5; // decreased speed from 10 to 5
      const CHILD_RED_MULTIPLIER = 1;
      const CHILD_YELLOW_MULTIPLIER = 1;
      const REPEL_FORCE = 0.002;
      const boundaryShapes = ["star", "circle"];
      let currentShapeIndex = Math.floor(Math.random() * boundaryShapes.length);

      // Create engine and world
      const engine = Engine.create();
      const world = engine.world;
      engine.world.gravity.y = 0;

      // Create renderer
      const render = Render.create({
        element: document.body,
        engine: engine,
        canvas: document.getElementById("world"),
        options: {
          width: width,
          height: height,
          wireframes: false,  // Enable wireframe mode
          background: "#1e1e1e"  // Night mode background color
        }
      });

      // Create walls
      const segments = 500;
      const wallThickness = 20;
      const walls = []; // keep the global walls array

      function createBoundaryWalls(shape) {
        // Remove any existing walls
        if (walls.length) {
          walls.forEach(w => World.remove(world, w));
          walls.length = 0;
        }
        if (shape === "star") {
          const points = 10;
          const outerRadius = containerRadius;
          const innerRadius = containerRadius * 0.5;
          const vertices = [];
          for (let i = 0; i < points; i++) {
            const angle = (2 * Math.PI / points) * i;
            const r = (i % 2 === 0) ? outerRadius : innerRadius;
            vertices.push({ x: containerX + r * Math.cos(angle), y: containerY + r * Math.sin(angle) });
          }
          for (let i = 0; i < points; i++) {
            const start = vertices[i];
            const end = vertices[(i + 1) % points];
            const mid = { x: (start.x + end.x) / 2, y: (start.y + end.y) / 2 };
            const dx = end.x - start.x, dy = end.y - start.y;
            const length = Math.hypot(dx, dy);
            const angle = Math.atan2(dy, dx);
            walls.push(Bodies.rectangle(mid.x, mid.y, length, wallThickness, { isStatic: true, angle: angle, label: "wall", render: { fillStyle: "#ff0" } }));
          }
        } else if (shape === "circle") {
          const segments = 400;
          const angleStep = (2 * Math.PI) / segments;
          for (let i = 0; i < segments; i++) {
            const theta = angleStep * i;
            const nextTheta = angleStep * (i + 1);
            const midTheta = (theta + nextTheta) / 2;
            const x = containerX + containerRadius * Math.cos(midTheta);
            const y = containerY + containerRadius * Math.sin(midTheta);
            const wallLength = 2 * containerRadius * Math.sin(angleStep / 2);
            walls.push(Bodies.rectangle(x, y, wallLength, wallThickness, { isStatic: true, angle: midTheta, label: "wall", render: { fillStyle: "#ff0" } }));
          }
        }
        World.add(world, walls);
      }

      createBoundaryWalls(boundaryShapes[currentShapeIndex]);

      // Ball creation
      const balls = [];
      let totalCreated = initialBallCount; // global counter for created balls
      let collisionCount = 0; // global collision counter

      function updateBallCounter() {
        const counter = document.getElementById("ball-counter");
        if (counter) {
          counter.innerText = "Balls: " + balls.length;
        }
      }

      // Sound control
      let isMuted = true;
      const collisionSound = document.getElementById("collision-sound");
      const muteToggle = document.getElementById("mute-toggle");

      muteToggle.addEventListener("click", () => {
        isMuted = !isMuted;
        muteToggle.innerText = isMuted ? "Unmute" : "Mute";  // reversed text assignment
        console.log(`Sound is now ${isMuted ? "muted" : "unmuted"}`);
      });

      // Global collision counter listener
      Events.on(engine, 'collisionStart', function(event) {
        collisionCount += event.pairs.length;
      });

      function toggleColor(ball) {
        // Stop toggling if ball is yellow
        if (!ball.custom) return;
        // Log current status
        console.log(`Ball ID: ${ball.id}, Current Status: ${ball.custom.status}`);
        // Toggle the color
        if (ball.custom.status === "red") {
          ball.render.fillStyle = "#0000ff";  // turn blue
          ball.custom.status = "blue";
        } else if (ball.custom.status === "blue") {
          ball.render.fillStyle = "#ff0000";  // turn red
          ball.custom.status = "red";
        } else if (ball.custom.status === "yellow") {  // 30% chance to turn red
          if (Math.random() < 0.3) {
            ball.render.fillStyle = "#ff0000";  // turn red
            ball.custom.status = "red";
            console.log(`Yellow Ball ID: ${ball.id} turned red`);
          }
        }
        // Schedule next toggle after 5 seconds (5000ms)
        ball._toggleTimer = setTimeout(() => toggleColor(ball), 5000);
      }

      function createBall(x, y, velocity = { x: 0, y: 0 }, color = "#ff6f61") {
        // Prevent creation if already 2 balls exist at the exact same position
        let duplicates = balls.filter(b => b.position.x === x && b.position.y === y).length;
        if (duplicates >= 1) return null;
        
        const ball = Bodies.circle(x, y, ballRadius, {
          restitution: 1.0,
          friction: 0,
          frictionAir: 0,
          label: 'ball',
          render: { fillStyle: color }
        });
        Body.setVelocity(ball, { x: velocity.x, y: velocity.y });
        // Set up continuous toggling for red and yellow balls
        ball.custom = { status: color === "#ff0000" ? "red" : "yellow" };
        ball._toggleTimer = setTimeout(() => toggleColor(ball), 5000);
        balls.push(ball);
        World.add(world, ball);
        updateBallCounter();
        // Play sound when a new ball is created
        if (!isMuted) {
          console.log("Playing sound for new ball creation");
          const soundClone = collisionSound.cloneNode(); // clone audio element to allow overlapping plays
          soundClone.play().catch(error => console.error("Sound play error:", error));
        }
        return ball;
      }

      // Create initial balls (create the hero ball with red color)
      for (let i = 0; i < initialBallCount; i++) {
        let placed = false;
        while (!placed) {
          const x = containerX + (Math.random() - 0.5) * (containerRadius - ballRadius * 3);
          const y = containerY + (Math.random() - 0.5) * (containerRadius - ballRadius * 3);

          if (Math.hypot(x - containerX, y - containerY) < containerRadius - ballRadius * 3) {
            const angle = Math.random() * 2 * Math.PI;
            createBall(
              x,
              y,
              {
                x: Math.cos(angle) * INITIAL_SPEED,
                y: Math.sin(angle) * INITIAL_SPEED
              },
              "#ff0000"  // hero ball is red
            );
            placed = true;
          }
        }
      }

      // Helper to generate a random hex color different from excludeColor
      function generateDifferentColor(excludeColor) {
        let color;
        do {
          color = "#" + Math.floor(Math.random()*16777215).toString(16).padStart(6, "0");
        } while (color.toLowerCase() === excludeColor.toLowerCase());
        return color;
      }
      
      // Modified collision event listener: Only create one child per hero ball collision,
      // every 10th ball becomes a hero (red), otherwise yellow ball is created with 0.8x speed.
      Events.on(engine, 'collisionStart', function(event) {
        if (balls.length >= MAX_BALLS) return;
        const processedHeroes = new Set();  // Track hero balls processed in this event
        event.pairs.forEach(pair => {
          const { bodyA, bodyB } = pair;
          // Identify the ball and wall from the pair
          const ball = bodyA.label === 'ball' ? bodyA : (bodyB.label === 'ball' ? bodyB : null);
          const wall = bodyA.label === 'wall' ? bodyA : (bodyB.label === 'wall' ? bodyB : null);
          if (ball && wall) {
            // Only process hero ball (red) if not already processed
            if (ball.render.fillStyle === "#ff0000" && !processedHeroes.has(ball.id)) {
              processedHeroes.add(ball.id);
              const currentSpeed = Math.hypot(ball.velocity.x, ball.velocity.y);
              // Determine ball color and speed multiplier
              totalCreated++;
              const newColor = (totalCreated % 10 === 0) ? "#ff0000" : "#ffff00";
              const multiplier = (newColor === "#ffff00") ? CHILD_YELLOW_MULTIPLIER : CHILD_RED_MULTIPLIER;
              const newSpeed = currentSpeed * multiplier;
              const inward = { x: containerX - ball.position.x, y: containerY - ball.position.y };
              const length = Math.hypot(inward.x, inward.y);
              const direction = { x: inward.x / length, y: inward.y / length };
              // Create child ball with the computed color and velocity
              const childBall = Bodies.circle(ball.position.x, ball.position.y, ballRadius, {
                restitution: 1.0,
                friction: 0,
                frictionAir: 0,
                label: 'ball',
                render: { fillStyle: newColor }
              });
              Body.setVelocity(childBall, { x: direction.x * newSpeed, y: direction.y * newSpeed });
              // If the spawned ball is red, initialize toggling
              if(newColor === "#ff0000") {
                childBall.custom = { status: "red" };
                childBall._toggleTimer = setTimeout(() => toggleColor(childBall), 5000);
              }
              balls.push(childBall);
              World.add(world, childBall);
              updateBallCounter();
              if (!isMuted) {
                console.log("Playing sound for new ball creation");
                const soundClone = collisionSound.cloneNode(); // clone audio element to allow overlapping plays
                soundClone.play().catch(error => console.error("Sound play error:", error));
              }
            }
          }
        });
      });

      // New collision event listener to repel yellow balls on wall collision
      Events.on(engine, 'collisionStart', function(event) {
        event.pairs.forEach(pair => {
          // Identify a yellow ball and a wall from the pair
          let yellowBall = null;
          let wall = null;
          if (pair.bodyA.label === 'ball' && pair.bodyA.render.fillStyle === "#ffff00" && pair.bodyB.label === 'wall') {
            yellowBall = pair.bodyA;
            wall = pair.bodyB;
          } else if (pair.bodyB.label === 'ball' && pair.bodyB.render.fillStyle === "#ffff00" && pair.bodyA.label === 'wall') {
            yellowBall = pair.bodyB;
            wall = pair.bodyA;
          }
          if (yellowBall && wall) {
            // Compute inward direction from ball position toward container center
            const dx = containerX - yellowBall.position.x;
            const dy = containerY - yellowBall.position.y;
            const distance = Math.hypot(dx, dy);
            const forceMagnitude = REPEL_FORCE; // tweak as needed
            const force = {
              x: (dx / distance) * forceMagnitude,
              y: (dy / distance) * forceMagnitude
            };
            Body.applyForce(yellowBall, yellowBall.position, force);
          }
        });
      });

      // New collision event listener to repel colliding red and yellow balls
      Events.on(engine, 'collisionStart', function(event) {
        event.pairs.forEach(pair => {
          if (pair.bodyA.label === 'ball' && pair.bodyB.label === 'ball') {
            const colorA = pair.bodyA.render.fillStyle;
            const colorB = pair.bodyB.render.fillStyle;
            // Process only red and yellow balls
            if ((colorA === "#ff0000" || colorA === "#ffff00") && (colorB === "#ff0000" || colorB === "#ffff00")) {
              const dx = pair.bodyB.position.x - pair.bodyA.position.x;
              const dy = pair.bodyB.position.y - pair.bodyA.position.y;
              const distance = Math.hypot(dx, dy);
              if (distance > 0) {
                const unit = { x: dx / distance, y: dy / distance };
                // Apply repelling force: bodyA is pushed opposite to the direction from A to B, bodyB is pushed in that direction
                const force = { x: unit.x * REPEL_FORCE, y: unit.y * REPEL_FORCE };
                Body.applyForce(pair.bodyA, pair.bodyA.position, { x: -force.x, y: -force.y });
                Body.applyForce(pair.bodyB, pair.bodyB.position, force);
              }
            }
          }
        });
      });

      // New collision event listener to turn blue balls to yellow upon colliding with another blue ball
      Events.on(engine, 'collisionStart', function(event) {
        event.pairs.forEach(pair => {
          if (pair.bodyA.label === 'ball' && pair.bodyB.label === 'ball') {
            const ballA = pair.bodyA, ballB = pair.bodyB;
            if (ballA.custom && ballB.custom && ballA.custom.status === "blue" && ballB.custom.status === "blue") {
              // Update both balls to yellow and stop toggling
              ballA.render.fillStyle = "#ffff00";
              ballB.render.fillStyle = "#ffff00";
              ballA.custom.status = "yellow";
              ballB.custom.status = "yellow";
              if (ballA._toggleTimer) { clearTimeout(ballA._toggleTimer); ballA._toggleTimer = null; }
              if (ballB._toggleTimer) { clearTimeout(ballB._toggleTimer); ballB._toggleTimer = null; }
            }
          }
        });
      });

      // Ensure all balls have the same speed throughout
      Events.on(engine, 'beforeUpdate', function() {
        balls.forEach(ball => {
          const speed = Math.hypot(ball.velocity.x, ball.velocity.y);
          if (speed > 0 && speed !== INITIAL_SPEED) {  // prevent division by zero
            const scale = INITIAL_SPEED / speed;
            Body.setVelocity(ball, { x: ball.velocity.x * scale, y: ball.velocity.y * scale });
          }
        });
      });

      // Cleanup function
      function cleanup() {
        for (let i = balls.length - 1; i >= 0; i--) {
          const ball = balls[i];
          const speed = Math.hypot(ball.velocity.x, ball.velocity.y);
          const distanceFromCenter = Math.hypot(
            ball.position.x - containerX,
            ball.position.y - containerY
          );

          if (speed > 20 || distanceFromCenter > containerRadius - ballRadius) {
            console.debug(`Removing ball at position (${ball.position.x}, ${ball.position.y}) with speed ${speed}`);
            World.remove(world, ball);
            balls.splice(i, 1);
          }
        }
        updateBallCounter();
      }

      // New global countdown variable (in seconds)
      let countdown = 60;
      
      // Update results display to include countdown
      function updateResults() {
        let countRed = 0, countBlue = 0, countYellow = 0;
        balls.forEach(ball => {
          if (ball.render.fillStyle === "#ff0000") countRed++;
          else if (ball.render.fillStyle === "#0000ff") countBlue++;
          else if (ball.render.fillStyle === "#ffff00") countYellow++;
        });
        const resultsEl = document.getElementById("results");
        if (resultsEl) {
          resultsEl.innerText = `Red: ${countRed}
Blue: ${countBlue}
Yellow: ${countYellow}
Collisions: ${collisionCount}
Next refresh in: ${countdown} seconds`;
        }
      }
      
      // New function: Update simulation variables display
      function updateVariables() {
        const varsEl = document.getElementById("simulation-variables");
        if (varsEl) {
          varsEl.innerText = `Canvas size: ${width} x ${height}
INITIAL_SPEED: ${INITIAL_SPEED}
CHILD_RED_MULTIPLIER: ${CHILD_RED_MULTIPLIER}
CHILD_YELLOW_MULTIPLIER: ${CHILD_YELLOW_MULTIPLIER}
REPEL_FORCE: ${REPEL_FORCE}`;
        }
      }
      
      // Remove previous 60-second setInterval and replace with a 1-second updater:
      setInterval(() => {
        countdown--;
        if (countdown <= 0) {
          updateResults();
          restartSimulation();
          countdown = 60;
        }
        updateResults();
        updateVariables();
      }, 1000);

      function restartSimulation() {
        // Remove all ball bodies
        balls.forEach(ball => World.remove(world, ball));
        balls.length = 0;
        totalCreated = initialBallCount;
        collisionCount = 0;
        updateBallCounter();
        // Update boundary shape
        currentShapeIndex = (currentShapeIndex + 1) % boundaryShapes.length;
        createBoundaryWalls(boundaryShapes[currentShapeIndex]);
        // Create a new initial hero ball
        let placed = false;
        while (!placed) {
          const x = containerX + (Math.random() - 0.5) * (containerRadius - ballRadius * 3);
          const y = containerY + (Math.random() - 0.5) * (containerRadius - ballRadius * 3);
          if (Math.hypot(x - containerX, y - containerY) < containerRadius - ballRadius * 3) {
            const angle = Math.random() * 2 * Math.PI;
            createBall(
              x,
              y,
              { x: Math.cos(angle) * INITIAL_SPEED, y: Math.sin(angle) * INITIAL_SPEED },
              "#ff0000"  // hero ball is red
            );
            placed = true;
          }
        }
      }

      // Run cleanup periodically
      setInterval(cleanup, 1000);

      // Start the simulation
      Render.run(render);
      const runner = Runner.create();
      Runner.run(runner, engine);

      // Adjust the view
      Render.lookAt(render, {
        min: { x: 0, y: 0 },
        max: { x: width, y: height }
      });
    </script>
  </body>
</html>